bool ariel::Algorithms::isWeighted(ariel::Graph& g)
{
    std::size_t numVertices = g.size();
    for (std::size_t i = 0; i < numVertices; ++i) {
        for (std::size_t j = 0; j < numVertices; ++j) {
            int weight = g[i][j];
            if (weight != 0 && weight != 1) {
                return true;  // Graph is weighted
            }
        }
    }
    return false;
}

std::string ariel::Algorithms::bellmanFord(ariel::Graph& g, std::size_t src, std::size_t dest)
{
    std::size_t numVertices = g.size();
    std::vector<int> distances(numVertices, std::numeric_limits<int>::max());
    std::vector<int> predecessor(numVertices, -1);  // Predecessor array to reconstruct the path
    distances[src] = 0;

    for (std::size_t i = 0; i < numVertices - 1; i++) {
        for (std::size_t u = 0; u < numVertices; u++) {
            for (std::size_t v = 0; v < numVertices; v++) {
                if (g[u][v] != std::numeric_limits<int>::max() &&
                    distances[u] != std::numeric_limits<int>::max() &&
                    distances[u] + g[u][v] < distances[v]) {
                    distances[v] = distances[u] + g[u][v];
                    predecessor[v] = u;
                }
            }
        }
    }

    for (std::size_t u = 0; u < numVertices; u++) {
        for (std::size_t v = 0; v < numVertices; v++) {
            if (g[u][v] != std::numeric_limits<int>::max() &&
                distances[u] != std::numeric_limits<int>::max() &&
                distances[u] + g[u][v] < distances[v]) {
                return "-1";
//                std::cout << "-1" << std::endl;
            }
        }
    }

    if (distances[dest] == std::numeric_limits<int>::max()) {
        return "-1";
//        std::cout <<"-1" << std::endl;
    } else {
        std::stack<int> path;
        size_t at = dest;
        while(at != -1)
        {
            path.push(at);
            at = (size_t)predecessor[at];
        }

        std::string result;  // Create an empty string to accumulate the output

        // Loop to process the stack until it's empty
        while (!path.empty()) {
            result += std::to_string(path.top());  // Add the top element of the stack to the result string
            path.pop();  // Remove the top element from the stack

            if (!path.empty()) {
                result += "->";  // Add an arrow if there are more elements to process
            }
        }

        // result += '\n';  // Optionally add a newline at the end of the result

        return result;  // Return the final constructed string
    }
    }


std::string ariel::Algorithms::BFS(ariel::Graph& g, std::size_t src, std::size_t dest)
{
    std::size_t numVertices = g.size();
    std::vector<bool> visited(numVertices, false);
    std::vector<int> predecessor(numVertices, -1);
    std::queue<std::size_t> queue;

    visited[src] = true;
    queue.push(src);

    while (!queue.empty()) {
        std::size_t current = queue.front();
        queue.pop();

        for (std::size_t i = 0; i < numVertices; ++i) {
            if (g[current][i] && !visited[i]) {
                visited[i] = true;
                predecessor[i] = current;
                queue.push(i);

                if (i == dest) {
                    std::stack<int> path;
                    size_t crawl = dest;
                    path.push(crawl);
                    while ((size_t)predecessor[crawl] != -1) {
                        path.push(predecessor[crawl]);
                        crawl = (size_t)predecessor[crawl];
                    }

                    std::string result;  // Initialize an empty string to store the result

                    // Loop through the stack until it is empty
                    while (!path.empty()) {
                        result += std::to_string(path.top());  // Convert the top element to string and add to the result
                        path.pop();  // Remove the top element from the stack
                        if (!path.empty()) {
                            result += "->";  // Add arrow if there are more elements
                        }
                    }

                    // result += '\n';  // Optionally add a newline at the end of the string

                    return result;
                }
                }
            }
        }
    return "-1";
//    std::cout << "-1" << std::endl;
}

std::string ariel::Algorithms::shortestPath(ariel::Graph& g, std::size_t start, std::size_t end) {
    if (isWeighted(g)) {
        return bellmanFord(g, start, end);
    } else {
        return BFS(g, start, end);
    }
}
