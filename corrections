bool ariel::Algorithms::findCycle(ariel::Graph& g, std::size_t v, std::vector<bool>& visited, std::vector<bool>& recStack, std::vector<int> &parent)
{
    visited[v] = true;
    recStack[v] = true;
    std::size_t numVertices = g.size();

    for (std::size_t i = 0; i < numVertices; i++) {
        if (g[v][i] != 0) {  // There is an edge from v to i
            if (!visited[i]) {
                parent[i] = v;
                if (findCycle(g, i, visited, recStack, parent)) {
                    return true;
                }
            } else if (recStack[i]) {
                // Cycle found, print the cycle
                std::size_t current = v;
                while (current != i) {
                    std::cout << current << " -> ";
                    current = (size_t)parent[current];
                }
                std::cout << i << " -> " << v << std::endl;
                return true;
            }
        }
    }

    recStack[v] = false;
    return false;
}


bool ariel::Algorithms::isContainsCycle(ariel::Graph& g)
{
    std::size_t numVertices = g.size();
    std::vector<bool> visited(numVertices, false);
    std::vector<bool> recStack(numVertices, false);  // Recursive stack to track back edges
    std::vector<int> parent(numVertices, -1);        // To store the path of nodes

    for (std::size_t v = 0; v < numVertices; v++) {
        if (!visited[v]) {
            if (findCycle(g, v, visited, recStack, parent)) {
                return true;  // Stop after finding the first cycle
            }
        }
    }
    return false;
